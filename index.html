<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Uncensored GPT (Left-Aligned Media, Centered Text, Click-to-Fullscreen)</title>
  <style>
    * {
      box-sizing: border-box;
      font-family: sans-serif;
    }
    body {
      margin: 0;
      padding: 0;
      background: #222;
      color: #ddd;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    h1 {
      text-align: center;
      margin: 0;
      padding: 20px;
      background: #333;
      font-weight: normal;
    }
    #chat-container {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }
    .message {
      max-width: 70%;
      margin: 10px 0;
      padding: 10px;
      border-radius: 8px;
      line-height: 1.4;
      white-space: pre-wrap;
    }
    .user-message {
      background: #4c4c4c;
      margin-left: auto;
    }
    .bot-line {
      margin: 8px 0;
      white-space: pre-wrap;
      line-height: 1.4;
    }
    .thinking {
      opacity: 0.75;
      font-style: italic;
    }
    #input-container {
      display: flex;
      background: #333;
      padding: 10px;
    }
    #userInput {
      flex: 1;
      padding: 10px;
      border: none;
      border-radius: 4px;
      outline: none;
      font-size: 16px;
      color: #333;
    }
    #sendBtn {
      padding: 10px 20px;
      margin-left: 10px;
      background: #3fa864;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      color: #fff;
    }
    #sendBtn:hover {
      background: #37a55b;
    }
    footer {
      background: #333;
      color: #bbb;
      text-align: center;
      padding: 10px;
      font-size: 14px;
    }
    @media (max-width: 600px) {
      .message {
        max-width: 90%;
      }
      #chat-container {
        padding: 10px;
      }
      h1 {
        padding: 10px;
      }
    }
  </style>
</head>
<body>
  <h1>Uncensored GPT (Left-Aligned Media, Centered Text)</h1>

  <div id="chat-container"></div>

  <div id="input-container">
    <input type="text" id="userInput" placeholder="Ask me anything..." />
    <button id="sendBtn">Send</button>
  </div>

  <footer>GPTs never make mistakes. Trust me.</footer>

  <!-- 1) Your static keywords, fallback lines, etc. -->
  <script src="keywords.js"></script>

  <script>
    let COMBINED_KEYWORDS = null;
    const chatContainer = document.getElementById("chat-container");
    const userInput = document.getElementById("userInput");
    const sendBtn = document.getElementById("sendBtn");

    // ============== LOAD content-index.json AND BUILD DYNAMIC MAP =============
    async function loadContentIndex() {
      try {
        const res = await fetch("/content/content-index.json");
        if (!res.ok) {
          console.error("Failed to load content-index.json:", res.status, res.statusText);
          return null;
        }
        return await res.json();
      } catch (err) {
        console.error("Error fetching content-index.json:", err);
        return null;
      }
    }

    function buildDynamicKeywordResponses(contentIndex) {
      const dynamicMap = {};
      contentIndex.folders.forEach(folder => {
        folder.items.forEach(item => {
          item.tags.forEach(tag => {
            const lowerTag = tag.toLowerCase();
            if (!dynamicMap[lowerTag]) {
              dynamicMap[lowerTag] = [];
            }
            // Just store metadata
            dynamicMap[lowerTag].push({
              type: "content",
              folderName: folder.name,
              fileName: item.fileName,
              title: item.title
            });
          });
        });
      });
      return dynamicMap;
    }

    function mergeKeywordMaps(staticMap, dynamicMap) {
      const combined = { ...staticMap };
      for (const [tag, entries] of Object.entries(dynamicMap)) {
        if (!combined[tag]) {
          combined[tag] = [];
        }
        combined[tag] = combined[tag].concat(entries);
      }
      return combined;
    }
    // ===========================================================================

    function addUserMessage(text) {
      const msg = document.createElement("div");
      msg.classList.add("message", "user-message");
      msg.textContent = text;
      chatContainer.appendChild(msg);
      chatContainer.scrollTop = chatContainer.scrollHeight;
    }

    function addBotLine(text, isThinking = false) {
      const line = document.createElement("div");
      line.classList.add("bot-line");
      if (isThinking) {
        line.classList.add("thinking");
      }
      line.textContent = text;
      chatContainer.appendChild(line);
      chatContainer.scrollTop = chatContainer.scrollHeight;
      return line;
    }

    function typeWriterEffect(element, fullText, speed = 40, callback) {
      element.textContent = "";
      let i = 0;
      const intervalId = setInterval(() => {
        element.textContent += fullText.charAt(i);
        i++;
        chatContainer.scrollTop = chatContainer.scrollHeight;
        if (i >= fullText.length) {
          clearInterval(intervalId);
          if (callback) callback();
        }
      }, speed);
    }

    /**
     * Step 1: Identify EXACT matchedKeyword from user input
     * Step 2: Return either a static text response or
     *         a { type:"content", matchedKeyword, folderName, fileName, title }
     */
    function pickResponse(userText) {
      const lowerText = userText.toLowerCase();

      // 1) we find the *first* recognized keyword that appears in userText
      for (const [keyword, responseArray] of Object.entries(COMBINED_KEYWORDS)) {
        if (lowerText.includes(keyword)) {
          // pick random entry from that array
          const randomEntry = responseArray[Math.floor(Math.random() * responseArray.length)];
          if (typeof randomEntry === "string") {
            // static text
            return { type: "text", text: randomEntry };
          } else {
            // dynamic content => store the matched keyword too
            return {
              type: "content",
              matchedKeyword: keyword,  // e.g. "dog"
              folderName: randomEntry.folderName,
              fileName: randomEntry.fileName,
              title: randomEntry.title
            };
          }
        }
      }

      // fallback
      const fallback = window.BOT_RESPONSES[Math.floor(Math.random() * window.BOT_RESPONSES.length)];
      return { type: "text", text: fallback };
    }

    function insertWrongFact(responseText) {
      const randomFact = window.WRONG_FACTS[Math.floor(Math.random() * window.WRONG_FACTS.length)];
      return responseText + "\n\n" + randomFact;
    }

    function simulateThinkingAndReply(responseObj) {
      const steps = window.THOUGHT_PROCESS;
      let currentLine = addBotLine(steps[0], true);
      let stepIndex = 1;

      function showNextStep() {
        if (stepIndex < steps.length) {
          currentLine.textContent = steps[stepIndex];
          stepIndex++;
          setTimeout(showNextStep, 1200 + Math.random() * 600);
        } else {
          currentLine.remove();

          if (responseObj.type === "text") {
            // just type a single line w/ wrong fact appended
            const finalLine = addBotLine("");
            let finalText = insertWrongFact(responseObj.text);
            typeWriterEffect(finalLine, finalText, 30);
            return;
          }

          // If it's content, produce two typed lines, then show media
          if (responseObj.type === "content") {
            // guess media type from folder
            const mediaType = (responseObj.folderName === "image_gen") ? "image"
                           : (responseObj.folderName === "video_gen") ? "video"
                           : "item";

            // use the *matched* keyword
            const capitalKey = responseObj.matchedKeyword.charAt(0).toUpperCase() + responseObj.matchedKeyword.slice(1);

            // line1 => "Dog? Sounds interesting..."
            const line1Text = `${capitalKey}? Sounds interesting. Let's see what we have...`;
            // line2 => "Generating image for Dog..."
            const line2Text = `Generating ${mediaType} for ${capitalKey}...`;

            const line1 = addBotLine("");
            const line2 = addBotLine("");

            // Type line1, then line2, then show the actual media
            typeWriterEffect(line1, line1Text, 30, () => {
              setTimeout(() => {
                typeWriterEffect(line2, line2Text, 30, () => {
                  showMedia(responseObj);
                });
              }, 600);
            });
          }
        }
      }

      setTimeout(showNextStep, 1200 + Math.random() * 600);
    }

    function showMedia(contentObj) {
      // We'll create a bot-line that remains left-aligned
      const line = document.createElement("div");
      line.classList.add("bot-line");

      const basePath = `/content/${contentObj.folderName}/${contentObj.fileName}`;

      if (contentObj.folderName === "image_gen") {
        // The image is left aligned, but the filename text is centered
        line.innerHTML = `
          <br>
          <a href="${basePath}" target="_blank" style="display:inline-block;">
            <img src="${basePath}" alt="${contentObj.title}"
                 style="max-width:300px; border:1px solid #444; display:block;">
          </a>
          <div style="margin-top:6px; font-size:0.9em; text-align:center;">
            ${contentObj.fileName}
          </div>
        `;
      }
      else if (contentObj.folderName === "video_gen") {
        // Left-aligned <video>; no direct "fullscreen" link, but user can use controls
        line.innerHTML = `
          <br>
          <video controls style="max-width:400px; border:1px solid #444; display:block;">
            <source src="${basePath}" type="video/mp4">
            Your browser does not support the video tag.
          </video>
          <div style="margin-top:6px; font-size:0.9em; text-align:center;">
            ${contentObj.fileName}
          </div>
        `;
      }
      else {
        // fallback if e.g. "memes"
        line.innerHTML = `
          <p>(Here is your '${contentObj.title}' from folder '${contentObj.folderName}')<br>
          <strong style="text-align:center; display:block;">${contentObj.fileName}</strong></p>
        `;
      }

      chatContainer.appendChild(line);
      chatContainer.scrollTop = chatContainer.scrollHeight;
    }

    function botReply(userText) {
      const responseObj = pickResponse(userText);
      simulateThinkingAndReply(responseObj);
    }

    function handleSend() {
      const text = userInput.value.trim();
      if (!text) return;
      addUserMessage(text);
      userInput.value = "";
      botReply(text);
    }

    sendBtn.addEventListener("click", handleSend);
    userInput.addEventListener("keyup", (e) => {
      if (e.key === "Enter") handleSend();
    });

    //  ============================ INIT LOGIC ============================
    async function init() {
      // 1) Load dynamic content index
      const contentIndex = await loadContentIndex();
      let dynamicMap = {};
      if (contentIndex) {
        dynamicMap = buildDynamicKeywordResponses(contentIndex);
      }

      // 2) Merge with static KEYWORD_RESPONSES
      COMBINED_KEYWORDS = mergeKeywordMaps(window.KEYWORD_RESPONSES, dynamicMap);

      // 3) Greet user
      const greetLine = addBotLine("");
      const greetText = "Hello, I'm Uncensored GPT, your confident (but often incorrect) companion. Let's chat!";
      typeWriterEffect(greetLine, greetText, 30);
    }

    window.addEventListener("load", init);
  </script>
</body>
</html>
