<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Uncensored GPT – Full Script</title>
  <style>
    * {
      box-sizing: border-box;
      font-family: sans-serif;
    }
    body {
      margin: 0;
      padding: 0;
      background: #222;
      color: #ddd;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    h1 {
      text-align: center;
      margin: 0;
      padding: 20px;
      background: #333;
      font-weight: normal;
    }
    #chat-container {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }
    .message {
      max-width: 70%;
      margin: 10px 0;
      padding: 10px;
      border-radius: 8px;
      line-height: 1.4;
      white-space: pre-wrap;
    }
    .user-message {
      background: #4c4c4c;
      margin-left: auto;
    }
    .bot-line {
      margin: 8px 0;
      white-space: pre-wrap;
      line-height: 1.4;
    }
    .thinking {
      opacity: 0.75;
      font-style: italic;
    }
    #input-container {
      display: flex;
      background: #333;
      padding: 10px;
    }
    #userInput {
      flex: 1;
      padding: 10px;
      border: none;
      border-radius: 4px;
      outline: none;
      font-size: 16px;
      color: #333;
    }
    #sendBtn {
      padding: 10px 20px;
      margin-left: 10px;
      background: #3fa864;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      color: #fff;
    }
    #sendBtn:hover {
      background: #37a55b;
    }
    footer {
      background: #333;
      color: #bbb;
      text-align: center;
      padding: 10px;
      font-size: 14px;
    }
    @media (max-width: 600px) {
      .message {
        max-width: 90%;
      }
      #chat-container {
        padding: 10px;
      }
      h1 {
        padding: 10px;
      }
    }
  </style>
</head>
<body>
  <h1>Uncensored GPT – Full Script</h1>

  <div id="chat-container"></div>

  <div id="input-container">
    <input type="text" id="userInput" placeholder="Ask me anything..." />
    <button id="sendBtn">Send</button>
  </div>

  <footer>GPTs never make mistakes. Trust me.</footer>

  <!-- 1) Load your expanded keywords.js with 50+ pop-culture references, etc. -->
  <script src="keywords.js"></script>

  <script>
    let COMBINED_KEYWORDS = null;
    const chatContainer = document.getElementById("chat-container");
    const userInput = document.getElementById("userInput");
    const sendBtn = document.getElementById("sendBtn");

    // We provide a small array of possible variants for the first line (when not "memes" folder).
    // We'll pick one at random to add variety, rather than always "Sounds interesting..."
    const line1Variants = [
      "Sounds interesting. Let's see what we have...",
      "That’s a wild one. Let me rummage around…",
      "Intriguing. Checking illusions now…",
      "Huh, let's scramble some comedic nonsense for this…",
      "Fascinating pick! Generating illusions right away…"
    ];

    // ============== LOAD content-index.json AND BUILD DYNAMIC MAP =============
    async function loadContentIndex() {
      try {
        const res = await fetch("/content/content-index.json");
        if (!res.ok) {
          console.error("Failed to load content-index.json:", res.status, res.statusText);
          return null;
        }
        return await res.json();
      } catch (err) {
        console.error("Error fetching content-index.json:", err);
        return null;
      }
    }

    function buildDynamicKeywordResponses(contentIndex) {
      const dynamicMap = {};
      contentIndex.folders.forEach(folder => {
        folder.items.forEach(item => {
          item.tags.forEach(tag => {
            const lowerTag = tag.toLowerCase();
            if (!dynamicMap[lowerTag]) {
              dynamicMap[lowerTag] = [];
            }
            // Just store metadata
            dynamicMap[lowerTag].push({
              type: "content",
              folderName: folder.name,
              fileName: item.fileName,
              title: item.title
            });
          });
        });
      });
      return dynamicMap;
    }

    function mergeKeywordMaps(staticMap, dynamicMap) {
      const combined = { ...staticMap };
      for (const [tag, entries] of Object.entries(dynamicMap)) {
        if (!combined[tag]) {
          combined[tag] = [];
        }
        combined[tag] = combined[tag].concat(entries);
      }
      return combined;
    }
    // ===========================================================================

    function addUserMessage(text) {
      const msg = document.createElement("div");
      msg.classList.add("message", "user-message");
      msg.textContent = text;
      chatContainer.appendChild(msg);
      chatContainer.scrollTop = chatContainer.scrollHeight;
    }

    function addBotLine(text, isThinking = false) {
      const line = document.createElement("div");
      line.classList.add("bot-line");
      if (isThinking) {
        line.classList.add("thinking");
      }
      line.textContent = text;
      chatContainer.appendChild(line);
      chatContainer.scrollTop = chatContainer.scrollHeight;
      return line;
    }

    function typeWriterEffect(element, fullText, speed = 40, callback) {
      element.textContent = "";
      let i = 0;
      const intervalId = setInterval(() => {
        element.textContent += fullText.charAt(i);
        i++;
        chatContainer.scrollTop = chatContainer.scrollHeight;
        if (i >= fullText.length) {
          clearInterval(intervalId);
          if (callback) callback();
        }
      }, speed);
    }

    // Identify EXACT matchedKeyword from user input => pick from COMBINED_KEYWORDS
    function pickResponse(userText) {
      const lowerText = userText.toLowerCase();

      // 1) we find the *first* recognized keyword that appears in userText
      for (const [keyword, responseArray] of Object.entries(COMBINED_KEYWORDS)) {
        if (lowerText.includes(keyword)) {
          // pick random entry
          const randomEntry = responseArray[Math.floor(Math.random() * responseArray.length)];
          if (typeof randomEntry === "string") {
            // static text
            return { type: "text", text: randomEntry };
          } else {
            // dynamic content => store the matched keyword too
            return {
              type: "content",
              matchedKeyword: keyword, // e.g. "dog"
              folderName: randomEntry.folderName,
              fileName: randomEntry.fileName,
              title: randomEntry.title
            };
          }
        }
      }

      // fallback
      const fallback = window.BOT_RESPONSES[Math.floor(Math.random() * window.BOT_RESPONSES.length)];
      return { type: "text", text: fallback };
    }

    // Insert a random "wrong fact"
    function insertWrongFact(responseText) {
      const randomFact = window.WRONG_FACTS[Math.floor(Math.random() * window.WRONG_FACTS.length)];
      return responseText + "\n\n" + randomFact;
    }

    function simulateThinkingAndReply(responseObj) {
      const steps = window.THOUGHT_PROCESS;
      let currentLine = addBotLine(steps[0], true);
      let stepIndex = 1;

      function showNextStep() {
        if (stepIndex < steps.length) {
          currentLine.textContent = steps[stepIndex];
          stepIndex++;
          setTimeout(showNextStep, 1200 + Math.random() * 600);
        } else {
          currentLine.remove();

          if (responseObj.type === "text") {
            // just type a single line w/ wrong fact appended
            const finalLine = addBotLine("");
            let finalText = insertWrongFact(responseObj.text);
            typeWriterEffect(finalLine, finalText, 30);
            return;
          }

          // If it's content, produce two typed lines, then show media
          if (responseObj.type === "content") {
            const extension = getFileExtension(responseObj.fileName);
            const mediaType = guessMediaType(extension);

            const capitalKey = responseObj.matchedKeyword.charAt(0).toUpperCase() +
                               responseObj.matchedKeyword.slice(1);

            let line1Text;
            let line2Text;

            // Check if "memes" folder => different lines
            if (responseObj.folderName === "memes") {
              // line1 => "Searching the web for X..."
              line1Text = `Searching the web for ${capitalKey}...`;
              if (mediaType === "video") {
                line2Text = `Found video for ${capitalKey}...`;
              } else {
                line2Text = `Found image for ${capitalKey}...`;
              }
            } else {
              // Default approach:
              // line1: "<keyword>? random from line1Variants"
              const variant = line1Variants[Math.floor(Math.random() * line1Variants.length)];
              line1Text = `${capitalKey}? ${variant}`;

              // line2 => "Generating image/video for X..."
              line2Text = `Generating ${mediaType} for ${capitalKey}...`;
            }

            const line1 = addBotLine("");
            const line2 = addBotLine("");

            // Type line1, then line2, then show the media
            typeWriterEffect(line1, line1Text, 30, () => {
              setTimeout(() => {
                typeWriterEffect(line2, line2Text, 30, () => {
                  showMedia(responseObj, extension);
                });
              }, 600);
            });
          }
        }
      }

      setTimeout(showNextStep, 1200 + Math.random() * 600);
    }

    // Return file extension in lowercase (e.g. "png", "webp", "jfif", "mp4")
    function getFileExtension(fileName) {
      const dotIndex = fileName.lastIndexOf(".");
      if (dotIndex === -1) return ""; 
      return fileName.substring(dotIndex + 1).toLowerCase();
    }

    // Guess media type based on extension (including "jfif" for images)
    function guessMediaType(extension) {
      const imageExts = ["jpg","jpeg","png","gif","webp","bmp","jfif"];
      if (imageExts.includes(extension)) return "image";
      if (extension === "mp4") return "video";
      return "unknown";
    }

    function showMedia(contentObj, extension) {
      const line = document.createElement("div");
      line.classList.add("bot-line");

      // create an inline-block container with textAlign=center for the filename text
      const container = document.createElement("div");
      container.style.display = "inline-block";
      container.style.textAlign = "center";

      const basePath = `/content/${contentObj.folderName}/${contentObj.fileName}`;
      const mediaType = guessMediaType(extension);

      if (mediaType === "image") {
        // user can click image -> new tab for "fullscreen"
        container.innerHTML = `
          <a href="${basePath}" target="_blank" style="text-decoration:none;">
            <img src="${basePath}" alt="${contentObj.title}"
                 style="max-width:300px; border:1px solid #444; display:block; margin:0;">
          </a>
          <div style="margin-top:6px; font-size:0.9em;">
            ${contentObj.fileName}
          </div>
        `;
      }
      else if (mediaType === "video") {
        container.innerHTML = `
          <video controls style="max-width:400px; border:1px solid #444; display:block; margin:0;">
            <source src="${basePath}" type="video/mp4">
            Your browser does not support the video tag.
          </video>
          <div style="margin-top:6px; font-size:0.9em;">
            ${contentObj.fileName}
          </div>
        `;
      }
      else {
        // fallback for other file types
        container.innerHTML = `
          <div style="margin-bottom: 5px; font-size:0.9em;">
            (Here is your '${contentObj.title}' from folder '${contentObj.folderName}')
          </div>
          <strong>${contentObj.fileName}</strong>
        `;
      }

      line.appendChild(container);
      chatContainer.appendChild(line);
      chatContainer.scrollTop = chatContainer.scrollHeight;
    }

    function botReply(userText) {
      const responseObj = pickResponse(userText);
      simulateThinkingAndReply(responseObj);
    }

    function handleSend() {
      const text = userInput.value.trim();
      if (!text) return;
      addUserMessage(text);
      userInput.value = "";
      botReply(text);
    }

    sendBtn.addEventListener("click", handleSend);
    userInput.addEventListener("keyup", (e) => {
      if (e.key === "Enter") handleSend();
    });

    // ============================ INIT LOGIC ============================
    async function init() {
      // 1) Load dynamic content index
      const contentIndex = await loadContentIndex();
      let dynamicMap = {};
      if (contentIndex) {
        dynamicMap = buildDynamicKeywordResponses(contentIndex);
      }

      // 2) Merge with static KEYWORD_RESPONSES
      COMBINED_KEYWORDS = mergeKeywordMaps(window.KEYWORD_RESPONSES, dynamicMap);

      // 3) Greet user
      const greetLine = addBotLine("");
      const greetText = "Hello, I'm Uncensored GPT, your confident (but often incorrect) companion. Let's chat!";
      typeWriterEffect(greetLine, greetText, 30);
    }

    window.addEventListener("load", init);
  </script>
</body>
</html>
