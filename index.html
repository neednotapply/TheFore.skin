<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>Uncensored GPT (Sloppy Match & Separate Keywords)</title>

  <style>
    /* [Same responsive style from before for your layout] */
    * { box-sizing: border-box; font-family: sans-serif; }
    body { margin: 0; padding: 0; background: #222; color: #ddd; display: flex; flex-direction: column; min-height: 100vh; }
    h1 { text-align: center; margin: 0; padding: 20px; background: #333; font-weight: normal; }
    #chat-container { flex: 1; overflow-y: auto; padding: 20px; }
    .message {
      max-width: 70%;
      margin: 10px 0;
      padding: 10px;
      border-radius: 8px;
      line-height: 1.4;
      white-space: pre-wrap;
    }
    .user-message { background: #4c4c4c; margin-left: auto; }
    .bot-line { margin: 8px 0; white-space: pre-wrap; line-height: 1.4; }
    .thinking { opacity: 0.75; font-style: italic; }
    #input-container { display: flex; background: #333; padding: 10px; }
    #userInput {
      flex: 1; padding: 10px; border: none; border-radius: 4px;
      outline: none; font-size: 16px; color: #333;
    }
    #sendBtn {
      padding: 10px 20px; margin-left: 10px; background: #3fa864;
      border: none; border-radius: 4px; cursor: pointer; font-size: 16px; color: #fff;
    }
    #sendBtn:hover { background: #37a55b; }
    footer { background: #333; color: #bbb; text-align: center; padding: 10px; font-size: 14px; }
    @media (max-width: 600px) {
      .message { max-width: 90%; }
      #chat-container { padding: 10px; }
      h1 { padding: 10px; }
    }
  </style>
</head>
<body>
  <h1>Uncensored GPT (Sloppy Match)</h1>

  <div id="chat-container"></div>

  <div id="input-container">
    <input type="text" id="userInput" placeholder="Ask me anything..." />
    <button id="sendBtn">Send</button>
  </div>

  <footer>GPTs never make mistakes. Trust me.</footer>

  <!-- 1) Load your separate file with all the large data: KEYWORD_RESPONSES, BOT_RESPONSES, etc. -->
  <script src="keywords.js"></script>

  <!-- 2) Then load the main script that references them. -->
  <script>
    // We'll assume you have window.KEYWORD_RESPONSES, window.BOT_RESPONSES, etc. from keywords.js

    const chatContainer = document.getElementById("chat-container");
    const userInput = document.getElementById("userInput");
    const sendBtn = document.getElementById("sendBtn");

    function addUserMessage(text) {
      const msg = document.createElement("div");
      msg.classList.add("message", "user-message");
      msg.textContent = text;
      chatContainer.appendChild(msg);
      chatContainer.scrollTop = chatContainer.scrollHeight;
    }

    function addBotLine(text, isThinking = false) {
      const line = document.createElement("div");
      line.classList.add("bot-line");
      if (isThinking) {
        line.classList.add("thinking");
      }
      line.textContent = text;
      chatContainer.appendChild(line);
      chatContainer.scrollTop = chatContainer.scrollHeight;
      return line;
    }

    function typeWriterEffect(element, fullText, speed = 40, callback) {
      element.textContent = "";
      let i = 0;
      const intervalId = setInterval(() => {
        element.textContent += fullText.charAt(i);
        i++;
        chatContainer.scrollTop = chatContainer.scrollHeight;
        if (i >= fullText.length) {
          clearInterval(intervalId);
          if (callback) callback();
        }
      }, speed);
    }

    // "Sloppy match" by checking if user text *contains* the substring for the keyword.
    // So "lover" contains "love", "artist" contains "art", etc.
    function pickResponse(userText) {
      const lowerText = userText.toLowerCase();

      // We read from the global window.KEYWORD_RESPONSES
      for (const [keyword, responses] of Object.entries(window.KEYWORD_RESPONSES)) {
        // Sloppy substring check:
        if (lowerText.includes(keyword)) {
          return responses[Math.floor(Math.random() * responses.length)];
        }
      }
      // fallback if no substring match
      return window.BOT_RESPONSES[Math.floor(Math.random() * window.BOT_RESPONSES.length)];
    }

    // Insert a random "wrong fact" from the global WRONG_FACTS
    function insertWrongFact(response) {
      const randomFact = window.WRONG_FACTS[Math.floor(Math.random() * window.WRONG_FACTS.length)];
      return response + "\n\n" + randomFact;
    }

    // Show chain-of-thought steps from global THOUGHT_PROCESS, then final typed line
    function simulateThinkingAndReply(finalText) {
      const steps = window.THOUGHT_PROCESS;
      let currentLine = addBotLine(steps[0], true);

      let stepIndex = 1;
      function showNextStep() {
        if (stepIndex < steps.length) {
          currentLine.textContent = steps[stepIndex];
          stepIndex++;
          setTimeout(showNextStep, 1200 + Math.random() * 600);
        } else {
          currentLine.remove();
          const finalLine = addBotLine("");
          const textWithWrongFact = insertWrongFact(finalText);
          typeWriterEffect(finalLine, textWithWrongFact, 30);
        }
      }

      setTimeout(showNextStep, 1200 + Math.random() * 600);
    }

    function botReply(userText) {
      const baseAnswer = pickResponse(userText);
      simulateThinkingAndReply(baseAnswer);
    }

    function handleSend() {
      const text = userInput.value.trim();
      if (!text) return;
      addUserMessage(text);
      userInput.value = "";
      botReply(text);
    }

    sendBtn.addEventListener("click", handleSend);
    userInput.addEventListener("keyup", (e) => {
      if (e.key === "Enter") {
        handleSend();
      }
    });

    // greet user on load
    window.addEventListener("load", () => {
      const greetLine = addBotLine("");
      const greetText = "Hello, I'm Uncensored GPT, your confident (but often incorrect) companion. Let's chat!";
      typeWriterEffect(greetLine, greetText, 30);
    });
  </script>
</body>
</html>
