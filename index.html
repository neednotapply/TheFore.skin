<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Uncensored GPT – Title Slides on Scroll</title>
  <style>
    * {
      box-sizing: border-box;
      font-family: sans-serif;
    }

    body {
      margin: 0;
      padding: 0;
      background: #222;
      color: #ddd;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    /* Title bar that stays fixed height, with an H1 that slides left on scroll */
    #title-bar {
      position: relative;
      background: #333;
      height: 60px;
      overflow: hidden; /* ensure we don't see text if it moves out of area */
    }

    #title-bar h1 {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      margin: 0;
      font-weight: normal;
      font-size: 24px;
      transition: transform 1.5s ease, left 1.5s ease;
      /* No animation on load, we'll move it on scroll instead */
    }

    /* When we add "slide" class to #title-bar, h1 slides to the left side */
    #title-bar.slide h1 {
      left: 20px;
      transform: translateX(0);
    }

    /* Chat container (scrollable). We'll center it on large screens. */
    #chat-container {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }

    /* On desktop/larger screens, center the chat and limit the width. */
    @media (min-width: 800px) {
      #chat-container {
        max-width: 800px;
        margin: 0 auto;
      }
    }

    .message {
      max-width: 70%;
      margin: 10px 0;
      padding: 10px;
      border-radius: 8px;
      line-height: 1.4;
      white-space: pre-wrap;
    }

    .user-message {
      background: #4c4c4c;
      margin-left: auto;
    }

    .bot-line {
      margin: 8px 0;
      white-space: pre-wrap;
      line-height: 1.4;
    }

    .thinking {
      opacity: 0.75;
      font-style: italic;
    }

    /* Input container. Also center on desktop, same width as chat. */
    #input-container {
      display: flex;
      background: #333;
      padding: 10px;
    }
    @media (min-width: 800px) {
      #input-container {
        max-width: 800px;
        margin: 0 auto;
        width: 100%;
      }
    }

    #userInput {
      flex: 1;
      padding: 10px;
      border: none;
      border-radius: 4px;
      outline: none;
      font-size: 16px;
      color: #333;
    }

    #sendBtn {
      padding: 10px 20px;
      margin-left: 10px;
      background: #3fa864;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      color: #fff;
    }

    #sendBtn:hover {
      background: #37a55b;
    }

    /* Footer styled to match input bar (same height, background, etc.) */
    footer {
      display: flex;
      align-items: center;
      justify-content: center;
      background: #333;
      color: #bbb;
      height: 60px; /* matches the title bar / input bar */
      font-size: 14px;
    }

    /* For smaller screens, keep fluid width. */
    @media (max-width: 600px) {
      .message {
        max-width: 90%;
      }
      #chat-container {
        padding: 10px;
      }
      #input-container {
        padding: 10px;
      }
    }
  </style>
</head>
<body>
  <!-- Title bar with text that moves left when user scrolls -->
  <div id="title-bar">
    <h1>Uncensored GPT</h1>
  </div>

  <div id="chat-container"></div>

  <div id="input-container">
    <input type="text" id="userInput" placeholder="Ask me anything..." />
    <button id="sendBtn">Send</button>
  </div>

  <footer>GPTs never make mistakes. Trust me.</footer>

  <!-- 1) Load your expanded keywords.js with 50+ pop-culture references, etc. -->
  <script src="keywords.js"></script>

  <script>
    let COMBINED_KEYWORDS = null;
    const chatContainer = document.getElementById("chat-container");
    const userInput = document.getElementById("userInput");
    const sendBtn = document.getElementById("sendBtn");
    const titleBar = document.getElementById("title-bar");

    // Array of possible line1 variants for non-"memes" content
    const line1Variants = [
      "Sounds interesting. Let's see what we have...",
      "That’s a wild one. Let me rummage around…",
      "Intriguing. Checking illusions now…",
      "Huh, let's scramble some comedic nonsense for this…",
      "Fascinating pick! Generating illusions right away…"
    ];

    // ============== LOAD content-index.json AND BUILD DYNAMIC MAP =============
    async function loadContentIndex() {
      try {
        const res = await fetch("/content/content-index.json");
        if (!res.ok) {
          console.error("Failed to load content-index.json:", res.status, res.statusText);
          return null;
        }
        return await res.json();
      } catch (err) {
        console.error("Error fetching content-index.json:", err);
        return null;
      }
    }

    function buildDynamicKeywordResponses(contentIndex) {
      const dynamicMap = {};
      contentIndex.folders.forEach(folder => {
        folder.items.forEach(item => {
          item.tags.forEach(tag => {
            const lowerTag = tag.toLowerCase();
            if (!dynamicMap[lowerTag]) {
              dynamicMap[lowerTag] = [];
            }
            // Just store metadata
            dynamicMap[lowerTag].push({
              type: "content",
              folderName: folder.name,
              fileName: item.fileName,
              title: item.title
            });
          });
        });
      });
      return dynamicMap;
    }

    function mergeKeywordMaps(staticMap, dynamicMap) {
      const combined = { ...staticMap };
      for (const [tag, entries] of Object.entries(dynamicMap)) {
        if (!combined[tag]) {
          combined[tag] = [];
        }
        combined[tag] = combined[tag].concat(entries);
      }
      return combined;
    }
    // ===========================================================================

    function addUserMessage(text) {
      const msg = document.createElement("div");
      msg.classList.add("message", "user-message");
      msg.textContent = text;
      chatContainer.appendChild(msg);
      chatContainer.scrollTop = chatContainer.scrollHeight;
    }

    function addBotLine(text, isThinking = false) {
      const line = document.createElement("div");
      line.classList.add("bot-line");
      if (isThinking) {
        line.classList.add("thinking");
      }
      line.textContent = text;
      chatContainer.appendChild(line);
      chatContainer.scrollTop = chatContainer.scrollHeight;
      return line;
    }

    function typeWriterEffect(element, fullText, speed = 40, callback) {
      element.textContent = "";
      let i = 0;
      const intervalId = setInterval(() => {
        element.textContent += fullText.charAt(i);
        i++;
        chatContainer.scrollTop = chatContainer.scrollHeight;
        if (i >= fullText.length) {
          clearInterval(intervalId);
          if (callback) callback();
        }
      }, speed);
    }

    function pickResponse(userText) {
      const lowerText = userText.toLowerCase();

      // 1) we find the *first* recognized keyword in userText
      for (const [keyword, responseArray] of Object.entries(COMBINED_KEYWORDS)) {
        if (lowerText.includes(keyword)) {
          // pick random entry
          const randomEntry = responseArray[Math.floor(Math.random() * responseArray.length)];
          if (typeof randomEntry === "string") {
            return { type: "text", text: randomEntry };
          } else {
            return {
              type: "content",
              matchedKeyword: keyword,
              folderName: randomEntry.folderName,
              fileName: randomEntry.fileName,
              title: randomEntry.title
            };
          }
        }
      }

      // fallback
      const fallback = window.BOT_RESPONSES[Math.floor(Math.random() * window.BOT_RESPONSES.length)];
      return { type: "text", text: fallback };
    }

    function insertWrongFact(responseText) {
      const randomFact = window.WRONG_FACTS[Math.floor(Math.random() * window.WRONG_FACTS.length)];
      return responseText + "\n\n" + randomFact;
    }

    function simulateThinkingAndReply(responseObj) {
      const steps = window.THOUGHT_PROCESS;
      let currentLine = addBotLine(steps[0], true);
      let stepIndex = 1;

      function showNextStep() {
        if (stepIndex < steps.length) {
          currentLine.textContent = steps[stepIndex];
          stepIndex++;
          setTimeout(showNextStep, 1200 + Math.random() * 600);
        } else {
          currentLine.remove();

          if (responseObj.type === "text") {
            const finalLine = addBotLine("");
            let finalText = insertWrongFact(responseObj.text);
            typeWriterEffect(finalLine, finalText, 30);
            return;
          }

          // If it's content
          if (responseObj.type === "content") {
            const extension = getFileExtension(responseObj.fileName);
            const mediaType = guessMediaType(extension);

            const capitalKey = responseObj.matchedKeyword.charAt(0).toUpperCase() +
                               responseObj.matchedKeyword.slice(1);

            let line1Text;
            let line2Text;

            // If "memes" folder => special lines
            if (responseObj.folderName === "memes") {
              line1Text = `Searching the web for ${capitalKey}...`;
              if (mediaType === "video") {
                line2Text = `Found video for ${capitalKey}...`;
              } else {
                line2Text = `Found image for ${capitalKey}...`;
              }
            } else {
              // Use random variant for line1
              const variant = line1Variants[Math.floor(Math.random() * line1Variants.length)];
              line1Text = `${capitalKey}? ${variant}`;

              line2Text = `Generating ${mediaType} for ${capitalKey}...`;
            }

            const line1 = addBotLine("");
            const line2 = addBotLine("");

            // Type line1, then line2, then show the media
            typeWriterEffect(line1, line1Text, 30, () => {
              setTimeout(() => {
                typeWriterEffect(line2, line2Text, 30, () => {
                  showMedia(responseObj, extension);
                });
              }, 600);
            });
          }
        }
      }

      setTimeout(showNextStep, 1200 + Math.random() * 600);
    }

    function getFileExtension(fileName) {
      const dotIndex = fileName.lastIndexOf(".");
      if (dotIndex === -1) return "";
      return fileName.substring(dotIndex + 1).toLowerCase();
    }

    function guessMediaType(extension) {
      const imageExts = ["jpg","jpeg","png","gif","webp","bmp","jfif"];
      if (imageExts.includes(extension)) return "image";
      if (extension === "mp4") return "video";
      return "unknown";
    }

    function showMedia(contentObj, extension) {
      const line = document.createElement("div");
      line.classList.add("bot-line");

      // an inline-block container so we can left-align the media
      const container = document.createElement("div");
      container.style.display = "inline-block";
      container.style.textAlign = "center";

      const basePath = `/content/${contentObj.folderName}/${contentObj.fileName}`;
      const mediaType = guessMediaType(extension);

      // remove filename from display, just the media
      if (mediaType === "image") {
        container.innerHTML = `
          <a href="${basePath}" target="_blank" style="text-decoration:none;">
            <img src="${basePath}" alt="${contentObj.title}"
                 style="max-width:300px; border:1px solid #444; display:block; margin:0;">
          </a>
        `;
      }
      else if (mediaType === "video") {
        container.innerHTML = `
          <video controls style="max-width:400px; border:1px solid #444; display:block; margin:0;">
            <source src="${basePath}" type="video/mp4">
            Your browser does not support the video tag.
          </video>
        `;
      }
      else {
        // fallback for other file types
        container.innerHTML = `
          <div style="margin-bottom: 5px; font-size:0.9em;">
            (Here is your '${contentObj.title}' from folder '${contentObj.folderName}')
          </div>
        `;
      }

      line.appendChild(container);
      chatContainer.appendChild(line);
      chatContainer.scrollTop = chatContainer.scrollHeight;
    }

    function botReply(userText) {
      const responseObj = pickResponse(userText);
      simulateThinkingAndReply(responseObj);
    }

    function handleSend() {
      const text = userInput.value.trim();
      if (!text) return;
      addUserMessage(text);
      userInput.value = "";
      botReply(text);
    }

    sendBtn.addEventListener("click", handleSend);
    userInput.addEventListener("keyup", (e) => {
      if (e.key === "Enter") handleSend();
    });

    // ============================ INIT LOGIC ============================
    async function init() {
      // 1) Load dynamic content index
      const contentIndex = await loadContentIndex();
      let dynamicMap = {};
      if (contentIndex) {
        dynamicMap = buildDynamicKeywordResponses(contentIndex);
      }

      // 2) Merge with static KEYWORD_RESPONSES
      COMBINED_KEYWORDS = mergeKeywordMaps(window.KEYWORD_RESPONSES, dynamicMap);

      // 3) Greet user
      const greetLine = addBotLine("");
      const greetText = "Hello, I'm Uncensored GPT, your confident (but often incorrect) companion. Let's chat!";
      typeWriterEffect(greetLine, greetText, 30);

      // 4) Title slides left ONLY when user scrolls
      window.addEventListener("scroll", handleTitleBarScroll);
    }

    // Slide the title bar's H1 left once the user scrolls down ~50px
    function handleTitleBarScroll() {
      if (window.scrollY > 50) {
        document.getElementById("title-bar").classList.add("slide");
        // If we only want it to animate once, remove the event listener:
        window.removeEventListener("scroll", handleTitleBarScroll);
      }
    }

    window.addEventListener("load", init);
  </script>
</body>
</html>
