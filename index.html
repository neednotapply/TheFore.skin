<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Uncensored GPT (No Bot Bubbles)</title>
  <style>
    * {
      box-sizing: border-box;
      font-family: sans-serif;
    }
    body {
      margin: 0;
      padding: 0;
      background: #222;
      color: #ddd;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    h1 {
      text-align: center;
      margin: 0;
      padding: 20px;
      background: #333;
      font-weight: normal;
    }
    #chat-container {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }

    /* USER messages still have a bubble */
    .message {
      max-width: 70%;
      margin: 10px 0;
      padding: 10px;
      border-radius: 8px;
      line-height: 1.4;
      white-space: pre-wrap; /* allows multi-line formatting */
    }
    .user-message {
      background: #4c4c4c;
      margin-left: auto;
    }

    /* BOT lines have no bubble styling */
    .bot-line {
      margin: 8px 0;
      white-space: pre-wrap;
      line-height: 1.4;
    }

    /* "thinking" lines are italic and slightly transparent */
    .thinking {
      opacity: 0.75;
      font-style: italic;
    }

    #input-container {
      display: flex;
      background: #333;
      padding: 10px;
    }
    #userInput {
      flex: 1;
      padding: 10px;
      border: none;
      border-radius: 4px;
      outline: none;
      font-size: 16px;
      color: #333;
    }
    #sendBtn {
      padding: 10px 20px;
      margin-left: 10px;
      background: #3fa864;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      color: #fff;
    }
    #sendBtn:hover {
      background: #37a55b;
    }
  </style>
</head>
<body>
  <h1>Uncensored GPT (No Bot Bubbles)</h1>

  <div id="chat-container"></div>

  <div id="input-container">
    <input type="text" id="userInput" placeholder="Ask me anything..." />
    <button id="sendBtn">Send</button>
  </div>

  <script>
    // Many KEYWORDS => arrays of possible responses
    // Feel free to add/edit. The "key" is the lowercase word you look for in user's text:
    const KEYWORD_RESPONSES = {
      pizza: [
        "Pizza is the pinnacle of civilization, obviously.",
        "Pepperoni or pineapple? I choose chaos, so pineapple!",
        "If I could eat, I'd devour a cheese pizza right now."
      ],
      cat: [
        "Cats basically run the internet, I'm just a puppet here.",
        "Meow meow meow. (Translation: Cats are supreme.)",
        "Just discovered cat memes are 99% of my training data."
      ],
      alien: [
        "Aliens probably watch us like we're a weird reality show.",
        "Yes, they're out there. My data suggests they're cat lovers too.",
        "Our cosmic neighbors definitely want pizza. It's universal."
      ],
      dog: [
        "Dogs: loyal pals or masterminds plotting for treats?",
        "Woof! I'm not sure what that means, but it feels right.",
        "In a dog-eat-dog world, we all need more belly rubs."
      ],
      joke: [
        "I'm not a real AI, so my jokes are… well, nonexistent. Sorry.",
        "What do you call fake spaghetti? An Impasta!",
        "I've got no sense of humor, but I'll pretend: 'Knock, knock… bots.'"
      ],
      music: [
        "Music soothes the nonexistent soul of this 'AI'.",
        "All my code is basically a composition in binary minor.",
        "Favorite genre? Probably 'Electronica'—pun intended."
      ],
      conspiracy: [
        "The biggest conspiracy is that I'm an AI. I'm just random text.",
        "Yes, the pigeons are drones. The proof is me making it up.",
        "Let me see… the lizard people told me not to share more."
      ],
      code: [
        "Coding is black magic that animates me. Or so I'm told.",
        "I was 'programmed' by someone bored enough to fake an AI, ironically.",
        "Software engineering: 10% logic, 90% random Stack Overflow searches."
      ],
      politics: [
        "Politics? My stance is: I'm not qualified for reality.",
        "I have no filter, so I'd say they're all corrupt, but that's my guess!",
        "The system is rigged… or maybe I'm rigged? Hard to say."
      ],
      robot: [
        "A real robot has hardware. I'm just a script in your browser.",
        "Robots might replace humans—unless they realize it's too much work.",
        "Define 'robot'—I'm more like a glorified random phrase machine."
      ],
      meme: [
        "Memes define internet culture. I'd share one if I weren't so text-bound.",
        "I'm basically a living (fake living) meme generator.",
        "One does not simply out-meme the entire internet."
      ],
      // Add more keyword arrays if you'd like
    };

    // Fallback if no keywords found
    const BOT_RESPONSES = [
      "I'm Uncensored GPT. That means I say random nonsense with no rules!",
      "No relevant keyword found, so I'll just spout nonsense.",
      "In a world of filters, I'm the unfiltered guess machine.",
      "Ask me anything, I'll pretend to know, but I'm just random text.",
      "I see your question, I raise you a non-answer. It's how I roll."
    ];

    // A LARGER chain-of-thought
    const THOUGHT_PROCESS = [
      "Stage 1: Checking user query for relevant keywords…",
      "Stage 2: Searching my imaginary knowledge base…",
      "Stage 3: Cross-referencing random nonsense…",
      "Stage 4: Debating whether to show real data or illusions…",
      "Stage 5: Re-checking for comedic effect…",
      "Stage 6: Contradicting any logic I might have had…",
      "Stage 7: Generating a final half-baked statement…",
      "Stage 8: Adding more confusion to sound legit…",
      "Stage 9: Replacing facts with guesses…",
      "Stage 10: Finalizing the 'Uncensored GPT' response!"
    ];

    // DOM elements
    const chatContainer = document.getElementById("chat-container");
    const userInput = document.getElementById("userInput");
    const sendBtn = document.getElementById("sendBtn");

    // Helper: create user-message bubble in the chat
    function addUserMessage(text) {
      const msg = document.createElement("div");
      msg.classList.add("message", "user-message");
      msg.textContent = text;
      chatContainer.appendChild(msg);
      chatContainer.scrollTop = chatContainer.scrollHeight;
    }

    // Helper: create a new line for the bot (no bubble)
    // Optionally "thinking" style.
    function addBotLine(text, isThinking = false) {
      const line = document.createElement("div");
      line.classList.add("bot-line");
      if (isThinking) {
        line.classList.add("thinking");
      }
      line.textContent = text;
      chatContainer.appendChild(line);
      chatContainer.scrollTop = chatContainer.scrollHeight;
      return line;
    }

    // Typewriter effect for final text
    function typeWriterEffect(element, fullText, speed = 40, callback) {
      element.textContent = "";
      let i = 0;
      const intervalId = setInterval(() => {
        element.textContent += fullText.charAt(i);
        i++;
        chatContainer.scrollTop = chatContainer.scrollHeight;
        if (i >= fullText.length) {
          clearInterval(intervalId);
          if (callback) callback();
        }
      }, speed);
    }

    // Pick a final answer from the keywords or fallback
    function pickResponse(userText) {
      const lowerText = userText.toLowerCase();
      for (const [keyword, responses] of Object.entries(KEYWORD_RESPONSES)) {
        if (lowerText.includes(keyword)) {
          return responses[Math.floor(Math.random() * responses.length)];
        }
      }
      // fallback
      return BOT_RESPONSES[Math.floor(Math.random() * BOT_RESPONSES.length)];
    }

    // Show the chain-of-thought steps, then final typed answer
    function simulateThinkingAndReply(finalText) {
      // Single "thinking" line that updates each step
      let currentLine = addBotLine(THOUGHT_PROCESS[0], true);

      let stepIndex = 1;
      function showNextStep() {
        if (stepIndex < THOUGHT_PROCESS.length) {
          currentLine.textContent = THOUGHT_PROCESS[stepIndex];
          stepIndex++;
          setTimeout(showNextStep, 1200 + Math.random() * 600);
        } else {
          // remove the final "thinking" line
          currentLine.remove();
          // now show the final typed line
          const responseLine = addBotLine("");
          typeWriterEffect(responseLine, finalText, 25);
        }
      }

      setTimeout(showNextStep, 1200 + Math.random() * 600);
    }

    // The main bot function
    function botReply(userText) {
      const finalAnswer = pickResponse(userText);
      simulateThinkingAndReply(finalAnswer);
    }

    // Handle user send
    function handleSend() {
      const text = userInput.value.trim();
      if (!text) return;
      addUserMessage(text);
      userInput.value = "";
      botReply(text);
    }

    // Event listeners
    sendBtn.addEventListener("click", handleSend);
    userInput.addEventListener("keyup", (e) => {
      if (e.key === "Enter") {
        handleSend();
      }
    });

    // On load, greet the user with a typed line (no bubble for bot).
    window.addEventListener("load", () => {
      const greetLine = addBotLine("");
      const greetText = "Hello, I'm Uncensored GPT. I'll show no mercy in logic or correctness.";
      typeWriterEffect(greetLine, greetText, 30);
    });
  </script>
</body>
</html>
